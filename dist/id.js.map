{"version":3,"file":"id.js","names":["getIdForAddress","address","ID","findOne","getIdKeyForAddress","id","_id","wasIdValidForAddressAt","block","addresses","signingAddress","find","a","nextSigningAddress","validAtBlock","firstSeenOK","firstSeen","currentAddress","handleAliasTransaction","doc","type","idKey","hash","identity","sequence","identityTxId","signatureAddress","validAddress","updateOne","$set","handleIDTransaction","existing","txAlreadyInIds","txId","lastAddress","length","$addToSet","useIdChecking","idKeyShouldBe","bsv","encoding","Base58","crypto","Hash","ripemd160","Buffer","from","toString","Error","insert","rootAddress"],"sources":["../src/id.js"],"sourcesContent":["import bsv from 'bsv';\nimport { ID } from './schemas/id';\n\nexport const getIdForAddress = async function (address) {\n  return ID.findOne({\n    'addresses.address': address,\n  });\n};\n\nexport const getIdKeyForAddress = async function (address) {\n  const id = await getIdForAddress(address);\n\n  return id ? id._id : null;\n};\n\nexport const wasIdValidForAddressAt = async function (address, block, id) {\n  id = id || await getIdForAddress(address) || { addresses: [] };\n\n  if (block) {\n    const signingAddress = id.addresses.find((a) => {\n      return a.address === address;\n    });\n\n    const nextSigningAddress = id.addresses.find((a) => {\n      return a.block > signingAddress.block;\n    });\n\n    const validAtBlock = signingAddress\n      && signingAddress.block <= block\n      && (\n        !nextSigningAddress\n        || nextSigningAddress.block > block\n      );\n\n    const firstSeenOK = !block || block >= id.firstSeen;\n\n    return firstSeenOK && !!signingAddress && validAtBlock;\n  }\n\n  // we accept mempool transactions with the current address only\n  return address === id.currentAddress;\n};\n\n/**\n * Alias transactions will update the identity field of the id\n *\n * @param doc\n * @returns {Promise<void>}\n */\nexport const handleAliasTransaction = async function (doc) {\n  if (doc.type !== 'ALIAS') return;\n\n  const idKey = doc.hash;\n  const identity = doc.sequence;\n  const identityTxId = doc._id;\n  const id = await ID.findOne({ _id: idKey });\n  const validAddress = await wasIdValidForAddressAt(doc.signatureAddress, doc.block, id);\n  if (id && validAddress) {\n    await ID.updateOne({\n      _id: idKey,\n    }, {\n      $set: {\n        identity,\n        identityTxId,\n      },\n    });\n  }\n};\n\nexport const handleIDTransaction = async function (doc) {\n  if (doc.type !== 'ID') return;\n\n  const idKey = doc.hash;\n\n  const existing = await ID.findOne({ _id: idKey });\n  if (existing) {\n    // we must first check whether this transaction has already been added to 'addresses'\n    const txAlreadyInIds = existing.addresses.find((address) => {\n      return address.txId === doc._id;\n    });\n    if (txAlreadyInIds) {\n      // we will only update the block here, otherwise something strange is going on\n      if (doc.block) {\n        await ID.updateOne({\n          _id: doc.hash,\n          'addresses.txId': doc._id,\n        }, {\n          $set: {\n            'addresses.$.block': doc.block,\n          },\n        });\n      }\n\n      // If the ID is new and now only being mined, than we also need to set firstSeen\n      if (!existing.firstSeen && existing.addresses[0].txId === doc._id) {\n        await ID.updateOne({\n          _id: doc.hash,\n        }, {\n          $set: {\n            firstSeen: doc.block,\n          },\n        });\n      }\n    } else {\n      // we must check here whether the new ID transaction was signed by the previous one\n      const lastAddress = existing.addresses[existing.addresses.length - 1];\n      if (lastAddress.address === doc.signatureAddress) {\n        await ID.updateOne({\n          _id: doc.hash,\n        }, {\n          $set: {\n            currentAddress: doc.sequence,\n          },\n          $addToSet: {\n            addresses: {\n              address: doc.sequence,\n              txId: doc._id,\n              block: doc.block,\n            },\n          },\n        });\n      }\n    }\n  } else {\n    // new ID - the idKey (hash) should be a hash of the rootAddress !!!\n    // but only from block 675400\n    // turned off for now\n    const useIdChecking = false;\n    if (useIdChecking && (!doc.block || doc.block > 675400)) {\n      const idKeyShouldBe = bsv.encoding.Base58(\n        bsv.crypto.Hash.ripemd160(\n          Buffer.from(doc.signatureAddress),\n        ),\n      ).toString();\n      if (idKeyShouldBe !== doc.hash) {\n        throw new Error('Id key does not match root address');\n      }\n    }\n\n    await ID.insert({\n      _id: doc.hash,\n      firstSeen: doc.block,\n      rootAddress: doc.signatureAddress,\n      currentAddress: doc.sequence,\n      addresses: [{\n        address: doc.sequence,\n        txId: doc._id,\n        block: doc.block,\n      }],\n    });\n  }\n};\n"],"mappings":"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"}